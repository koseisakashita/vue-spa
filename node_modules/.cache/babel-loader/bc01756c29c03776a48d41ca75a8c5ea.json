{"remainingRequest":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/thread-loader/dist/cjs.js!/Users/sakashita/Documents/software/sample-vue-app/node_modules/babel-loader/lib/index.js!/Users/sakashita/Documents/software/sample-vue-app/node_modules/vuetify/lib/mixins/maskable.js","dependencies":[{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/vuetify/lib/mixins/maskable.js","mtime":499162500000},{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQiOwoKLyoqCiAqIE1hc2thYmxlCiAqCiAqIEBtaXhpbgogKgogKiBDcmVhdGVzIGFuIGlucHV0IG1hc2sgdGhhdCBpcwogKiBnZW5lcmF0ZWQgZnJvbSBhIG1hc2tlZCBzdHIKICoKICogRXhhbXBsZTogbWFzaz0iIyMjIyAjIyMjICMjIyMgIyMjIyIKICovCmltcG9ydCB7IGlzTWFza0RlbGltaXRlciwgbWFza1RleHQgYXMgX21hc2tUZXh0LCB1bm1hc2tUZXh0IGFzIF91bm1hc2tUZXh0IH0gZnJvbSAnLi4vdXRpbC9tYXNrJzsKLyogQHZ1ZS9jb21wb25lbnQgKi8KCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnbWFza2FibGUnLAogIHByb3BzOiB7CiAgICBkb250RmlsbE1hc2tCbGFua3M6IEJvb2xlYW4sCiAgICBtYXNrOiB7CiAgICAgIHR5cGU6IFtPYmplY3QsIFN0cmluZ10sCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0sCiAgICByZXR1cm5NYXNrZWRWYWx1ZTogQm9vbGVhbiwKICAgIHZhbHVlOiB7CiAgICAgIHJlcXVpcmVkOiBmYWxzZQogICAgfQogIH0sCiAgZGF0YTogZnVuY3Rpb24gZGF0YSh2bSkgewogICAgcmV0dXJuIHsKICAgICAgc2VsZWN0aW9uOiAwLAogICAgICBsYXp5U2VsZWN0aW9uOiAwLAogICAgICBsYXp5VmFsdWU6IHZtLnZhbHVlLAogICAgICBwcmVEZWZpbmVkOiB7CiAgICAgICAgJ2NyZWRpdC1jYXJkJzogJyMjIyMgLSAjIyMjIC0gIyMjIyAtICMjIyMnLAogICAgICAgICdkYXRlJzogJyMjLyMjLyMjIyMnLAogICAgICAgICdkYXRlLXdpdGgtdGltZSc6ICcjIy8jIy8jIyMjICMjOiMjJywKICAgICAgICAncGhvbmUnOiAnKCMjIykgIyMjIC0gIyMjIycsCiAgICAgICAgJ3NvY2lhbCc6ICcjIyMtIyMtIyMjIycsCiAgICAgICAgJ3RpbWUnOiAnIyM6IyMnLAogICAgICAgICd0aW1lLXdpdGgtc2Vjb25kcyc6ICcjIzojIzojIycKICAgICAgfQogICAgfTsKICB9LAogIGNvbXB1dGVkOiB7CiAgICBtYXNrZWQ6IGZ1bmN0aW9uIG1hc2tlZCgpIHsKICAgICAgdmFyIHByZURlZmluZWQgPSB0aGlzLnByZURlZmluZWRbdGhpcy5tYXNrXTsKICAgICAgdmFyIG1hc2sgPSBwcmVEZWZpbmVkIHx8IHRoaXMubWFzayB8fCAnJzsKICAgICAgcmV0dXJuIG1hc2suc3BsaXQoJycpOwogICAgfQogIH0sCiAgd2F0Y2g6IHsKICAgIC8qKgogICAgICogTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXMgaW4gdGhlIGNvcnJlY3QKICAgICAqIGxvY2F0aW9uIHdoZW4gdGhlIG1hc2sgY2hhbmdlcwogICAgICovCiAgICBtYXNrOiBmdW5jdGlvbiBtYXNrKCkgewogICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgaWYgKCF0aGlzLiRyZWZzLmlucHV0KSByZXR1cm47CiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuJHJlZnMuaW5wdXQudmFsdWU7CiAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMubWFza1RleHQoX3VubWFza1RleHQodGhpcy5sYXp5VmFsdWUpKTsKICAgICAgdmFyIHBvc2l0aW9uID0gMDsKICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uOwoKICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHNlbGVjdGlvbjsgaW5kZXgrKykgewogICAgICAgIGlzTWFza0RlbGltaXRlcihvbGRWYWx1ZVtpbmRleF0pIHx8IHBvc2l0aW9uKys7CiAgICAgIH0KCiAgICAgIHNlbGVjdGlvbiA9IDA7CgogICAgICBpZiAobmV3VmFsdWUpIHsKICAgICAgICBmb3IgKHZhciBfaW5kZXggPSAwOyBfaW5kZXggPCBuZXdWYWx1ZS5sZW5ndGg7IF9pbmRleCsrKSB7CiAgICAgICAgICBpc01hc2tEZWxpbWl0ZXIobmV3VmFsdWVbX2luZGV4XSkgfHwgcG9zaXRpb24tLTsKICAgICAgICAgIHNlbGVjdGlvbisrOwogICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IDApIGJyZWFrOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkgewogICAgICAgIF90aGlzLiRyZWZzLmlucHV0LnZhbHVlID0gbmV3VmFsdWU7CgogICAgICAgIF90aGlzLnNldENhcmV0UG9zaXRpb24oc2VsZWN0aW9uKTsKICAgICAgfSk7CiAgICB9CiAgfSwKICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQoKSB7CiAgICBpZiAoIXRoaXMubWFzayB8fCB0aGlzLnZhbHVlID09IG51bGwgfHwgIXRoaXMucmV0dXJuTWFza2VkVmFsdWUpIHJldHVybjsKICAgIHZhciB2YWx1ZSA9IHRoaXMubWFza1RleHQodGhpcy52YWx1ZSk7IC8vIFNlZSBpZiBtYXNrZWQgdmFsdWUgZG9lcyBub3QKICAgIC8vIG1hdGNoIHRoZSB1c2VyIGdpdmVuIHZhbHVlCgogICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlKSByZXR1cm47CiAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHZhbHVlKTsKICB9LAogIG1ldGhvZHM6IHsKICAgIHNldENhcmV0UG9zaXRpb246IGZ1bmN0aW9uIHNldENhcmV0UG9zaXRpb24oc2VsZWN0aW9uKSB7CiAgICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247CiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICAgICAgICBfdGhpczIuJHJlZnMuaW5wdXQgJiYgX3RoaXMyLiRyZWZzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKF90aGlzMi5zZWxlY3Rpb24sIF90aGlzMi5zZWxlY3Rpb24pOwogICAgICB9LCAwKTsKICAgIH0sCiAgICB1cGRhdGVSYW5nZTogZnVuY3Rpb24gdXBkYXRlUmFuZ2UoKSB7CiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovCiAgICAgIGlmICghdGhpcy4kcmVmcy5pbnB1dCkgcmV0dXJuOwogICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLm1hc2tUZXh0KHRoaXMubGF6eVZhbHVlKTsKICAgICAgdmFyIHNlbGVjdGlvbiA9IDA7CiAgICAgIHRoaXMuJHJlZnMuaW5wdXQudmFsdWUgPSBuZXdWYWx1ZTsKCiAgICAgIGlmIChuZXdWYWx1ZSkgewogICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuZXdWYWx1ZS5sZW5ndGg7IGluZGV4KyspIHsKICAgICAgICAgIGlmICh0aGlzLmxhenlTZWxlY3Rpb24gPD0gMCkgYnJlYWs7CiAgICAgICAgICBpc01hc2tEZWxpbWl0ZXIobmV3VmFsdWVbaW5kZXhdKSB8fCB0aGlzLmxhenlTZWxlY3Rpb24tLTsKICAgICAgICAgIHNlbGVjdGlvbisrOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5zZXRDYXJldFBvc2l0aW9uKHNlbGVjdGlvbik7IC8vIHRoaXMuJGVtaXQoKSBtdXN0IG9jY3VyIG9ubHkgd2hlbiBhbGwgaW50ZXJuYWwgdmFsdWVzIGFyZSBjb3JyZWN0CgogICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMucmV0dXJuTWFza2VkVmFsdWUgPyB0aGlzLiRyZWZzLmlucHV0LnZhbHVlIDogdGhpcy5sYXp5VmFsdWUpOwogICAgfSwKICAgIG1hc2tUZXh0OiBmdW5jdGlvbiBtYXNrVGV4dCh0ZXh0KSB7CiAgICAgIHJldHVybiB0aGlzLm1hc2sgPyBfbWFza1RleHQodGV4dCwgdGhpcy5tYXNrZWQsIHRoaXMuZG9udEZpbGxNYXNrQmxhbmtzKSA6IHRleHQ7CiAgICB9LAogICAgdW5tYXNrVGV4dDogZnVuY3Rpb24gdW5tYXNrVGV4dCh0ZXh0KSB7CiAgICAgIHJldHVybiB0aGlzLm1hc2sgJiYgIXRoaXMucmV0dXJuTWFza2VkVmFsdWUgPyBfdW5tYXNrVGV4dCh0ZXh0KSA6IHRleHQ7CiAgICB9LAogICAgLy8gV2hlbiB0aGUgaW5wdXQgY2hhbmdlcyBhbmQgaXMKICAgIC8vIHJlLWNyZWF0ZWQsIGVuc3VyZSB0aGF0IHRoZQogICAgLy8gY2FyZXQgbG9jYXRpb24gaXMgY29ycmVjdAogICAgc2V0U2VsZWN0aW9uUmFuZ2U6IGZ1bmN0aW9uIHNldFNlbGVjdGlvblJhbmdlKCkgewogICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnVwZGF0ZVJhbmdlKTsKICAgIH0sCiAgICByZXNldFNlbGVjdGlvbnM6IGZ1bmN0aW9uIHJlc2V0U2VsZWN0aW9ucyhpbnB1dCkgewogICAgICBpZiAoIWlucHV0LnNlbGVjdGlvbkVuZCkgcmV0dXJuOwogICAgICB0aGlzLnNlbGVjdGlvbiA9IGlucHV0LnNlbGVjdGlvbkVuZDsKICAgICAgdGhpcy5sYXp5U2VsZWN0aW9uID0gMDsKCiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnNlbGVjdGlvbjsgaW5kZXgrKykgewogICAgICAgIGlzTWFza0RlbGltaXRlcihpbnB1dC52YWx1ZVtpbmRleF0pIHx8IHRoaXMubGF6eVNlbGVjdGlvbisrOwogICAgICB9CiAgICB9CiAgfQp9Ow=="},{"version":3,"sources":["../../src/mixins/maskable.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Maskable\n *\n * @mixin\n *\n * Creates an input mask that is\n * generated from a masked str\n *\n * Example: mask=\"#### #### #### ####\"\n */\n\nimport {\n  isMaskDelimiter,\n  maskText,\n  unmaskText\n} from '../util/mask'\n\n/* @vue/component */\nexport default {\n  name: 'maskable',\n\n  props: {\n    dontFillMaskBlanks: Boolean,\n    mask: {\n      type: [Object, String],\n      default: null\n    },\n    returnMaskedValue: Boolean,\n    value: { required: false }\n  },\n\n  data: vm => ({\n    selection: 0,\n    lazySelection: 0,\n    lazyValue: vm.value,\n    preDefined: {\n      'credit-card': '#### - #### - #### - ####',\n      'date': '##/##/####',\n      'date-with-time': '##/##/#### ##:##',\n      'phone': '(###) ### - ####',\n      'social': '###-##-####',\n      'time': '##:##',\n      'time-with-seconds': '##:##:##'\n    }\n  }),\n\n  computed: {\n    masked () {\n      const preDefined = this.preDefined[this.mask]\n      const mask = preDefined || this.mask || ''\n\n      return mask.split('')\n    }\n  },\n\n  watch: {\n    /**\n     * Make sure the cursor is in the correct\n     * location when the mask changes\n     */\n    mask () {\n      if (!this.$refs.input) return\n\n      const oldValue = this.$refs.input.value\n      const newValue = this.maskText(unmaskText(this.lazyValue))\n      let position = 0\n      let selection = this.selection\n\n      for (let index = 0; index < selection; index++) {\n        isMaskDelimiter(oldValue[index]) || position++\n      }\n\n      selection = 0\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          isMaskDelimiter(newValue[index]) || position--\n          selection++\n          if (position <= 0) break\n        }\n      }\n\n      this.$nextTick(() => {\n        this.$refs.input.value = newValue\n        this.setCaretPosition(selection)\n      })\n    }\n  },\n\n  beforeMount () {\n    if (!this.mask ||\n      this.value == null ||\n      !this.returnMaskedValue\n    ) return\n\n    const value = this.maskText(this.value)\n\n    // See if masked value does not\n    // match the user given value\n    if (value === this.value) return\n\n    this.$emit('input', value)\n  },\n\n  methods: {\n    setCaretPosition (selection) {\n      this.selection = selection\n      window.setTimeout(() => {\n        this.$refs.input && this.$refs.input.setSelectionRange(this.selection, this.selection)\n      }, 0)\n    },\n    updateRange () {\n      /* istanbul ignore next */\n      if (!this.$refs.input) return\n\n      const newValue = this.maskText(this.lazyValue)\n      let selection = 0\n\n      this.$refs.input.value = newValue\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          if (this.lazySelection <= 0) break\n          isMaskDelimiter(newValue[index]) || this.lazySelection--\n          selection++\n        }\n      }\n\n      this.setCaretPosition(selection)\n      // this.$emit() must occur only when all internal values are correct\n      this.$emit('input', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue)\n    },\n    maskText (text) {\n      return this.mask ? maskText(text, this.masked, this.dontFillMaskBlanks) : text\n    },\n    unmaskText (text) {\n      return this.mask && !this.returnMaskedValue ? unmaskText(text) : text\n    },\n    // When the input changes and is\n    // re-created, ensure that the\n    // caret location is correct\n    setSelectionRange () {\n      this.$nextTick(this.updateRange)\n    },\n    resetSelections (input) {\n      if (!input.selectionEnd) return\n      this.selection = input.selectionEnd\n      this.lazySelection = 0\n\n      for (let index = 0; index < this.selection; index++) {\n        isMaskDelimiter(input.value[index]) || this.lazySelection++\n      }\n    }\n  }\n}\n"],"sourceRoot":""}]}