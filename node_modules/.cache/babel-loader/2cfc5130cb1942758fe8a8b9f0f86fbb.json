{"remainingRequest":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/babel-loader/lib/index.js!/Users/sakashita/Documents/software/sample-vue-app/node_modules/vuetify/lib/components/VSparkline/helpers/core.js","dependencies":[{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/vuetify/lib/components/VSparkline/helpers/core.js","mtime":499162500000},{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sakashita/Documents/software/sample-vue-app/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CgpmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7CiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgewogICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgewogICAgICBhcnIyW2ldID0gYXJyW2ldOwogICAgfQoKICAgIHJldHVybiBhcnIyOwogIH0gZWxzZSB7CiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpOwogIH0KfQoKZXhwb3J0IGZ1bmN0aW9uIGdlblBvaW50cyhwb2ludHMsIGJvdW5kYXJ5LCB0eXBlKSB7CiAgdmFyIG1pblggPSBib3VuZGFyeS5taW5YLAogICAgICBtaW5ZID0gYm91bmRhcnkubWluWSwKICAgICAgbWF4WCA9IGJvdW5kYXJ5Lm1heFgsCiAgICAgIG1heFkgPSBib3VuZGFyeS5tYXhZOwogIHZhciBub3JtYWxpc2VkUG9pbnRzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoaXRlbSkgewogICAgcmV0dXJuIHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IGl0ZW0gOiBpdGVtLnZhbHVlOwogIH0pOwogIHZhciB0b3RhbFBvaW50cyA9IG5vcm1hbGlzZWRQb2ludHMubGVuZ3RoOwogIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShub3JtYWxpc2VkUG9pbnRzKSkgKyAxOwogIHZhciBtaW5WYWx1ZSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShub3JtYWxpc2VkUG9pbnRzKSk7CiAgaWYgKG1pblZhbHVlKSBtaW5WYWx1ZSAtPSAxOwogIHZhciBncmlkWCA9IChtYXhYIC0gbWluWCkgLyAodG90YWxQb2ludHMgLSAxKTsKICBpZiAodHlwZSA9PT0gJ2JhcicpIGdyaWRYID0gbWF4WCAvIHRvdGFsUG9pbnRzOwogIHZhciBncmlkWSA9IChtYXhZIC0gbWluWSkgLyAobWF4VmFsdWUgLSBtaW5WYWx1ZSk7CiAgcmV0dXJuIG5vcm1hbGlzZWRQb2ludHMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsKICAgIHJldHVybiB7CiAgICAgIHg6IG1pblggKyBpbmRleCAqIGdyaWRYLAogICAgICB5OiBtYXhZIC0gKHZhbHVlIC0gbWluVmFsdWUpICogZ3JpZFkgKyArKGluZGV4ID09PSB0b3RhbFBvaW50cyAtIDEpICogMC4wMDAwMSAtICsoaW5kZXggPT09IDApICogMC4wMDAwMSwKICAgICAgdmFsdWU6IHZhbHVlCiAgICB9OwogIH0pOwp9"},{"version":3,"sources":["../../../../src/components/VSparkline/helpers/core.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;OAEM,SAAA,SAAA,CAAA,MAAA,EAAA,QAAA,EAAA,IAAA,EAGQ;AAAA,MAEJ,IAFI,GAEuB,QAFvB,CAAA,IAAA;AAAA,MAEE,IAFF,GAEuB,QAFvB,CAAA,IAAA;AAAA,MAEQ,IAFR,GAEuB,QAFvB,CAAA,IAAA;AAAA,MAEc,IAFd,GAEuB,QAFvB,CAAA,IAAA;AAGZ,MAAM,gBAAA,GAAmB,MAAA,CAAA,GAAA,CACvB,UAAA,IAAA,EAAA;AAAA,WAAS,OAAA,IAAA,KAAA,QAAA,GAAA,IAAA,GAAkC,IAAA,CAA3C,KAAA;AADF,GAAyB,CAAzB;AAGA,MAAM,WAAA,GAAc,gBAAA,CAApB,MAAA;AACA,MAAM,QAAA,GAAW,IAAA,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,EAAA,kBAAA,CAAA,gBAAA,CAAA,IAAjB,CAAA;AACA,MAAI,QAAA,GAAW,IAAA,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,EAAA,kBAAA,CAAf,gBAAe,CAAA,CAAf;AAEA,MAAA,QAAA,EAAc,QAAA,IAAA,CAAA;AACd,MAAI,KAAA,GAAQ,CAAC,IAAA,GAAD,IAAA,KAAiB,WAAA,GAA7B,CAAY,CAAZ;AACA,MAAI,IAAA,KAAJ,KAAA,EAAoB,KAAA,GAAQ,IAAA,GAAR,WAAA;AACpB,MAAM,KAAA,GAAQ,CAAC,IAAA,GAAD,IAAA,KAAiB,QAAA,GAA/B,QAAc,CAAd;AAEA,SAAO,gBAAA,CAAA,GAAA,CAAqB,UAAA,KAAA,EAAA,KAAA,EAAiB;AAC3C,WAAO;AACL,MAAA,CAAA,EAAG,IAAA,GAAO,KAAA,GADL,KAAA;AAEL,MAAA,CAAA,EACE,IAAA,GACA,CAAC,KAAA,GAAD,QAAA,IADA,KAAA,GAEA,EAAE,KAAA,KAAU,WAAA,GAAZ,CAAA,IAFA,OAAA,GAGA,EAAE,KAAA,KAAF,CAAA,IANG,OAAA;AAOL,MAAA,KAAA,EAAA;AAPK,KAAP;AADF,GAAO,CAAP;AAWD","sourcesContent":["import { SparklineItem, Boundary, Point } from '../VSparkline'\n\nexport function genPoints (\n  points: SparklineItem[],\n  boundary: Boundary,\n  type: String\n): Point[] {\n  const { minX, minY, maxX, maxY } = boundary\n  const normalisedPoints = points.map(\n    item => (typeof item === 'number' ? item : item.value)\n  )\n  const totalPoints = normalisedPoints.length\n  const maxValue = Math.max(...normalisedPoints) + 1\n  let minValue = Math.min(...normalisedPoints)\n\n  if (minValue) minValue -= 1\n  let gridX = (maxX - minX) / (totalPoints - 1)\n  if (type === 'bar') gridX = maxX / totalPoints\n  const gridY = (maxY - minY) / (maxValue - minValue)\n\n  return normalisedPoints.map((value, index) => {\n    return {\n      x: minX + index * gridX,\n      y:\n        maxY -\n        (value - minValue) * gridY +\n        +(index === totalPoints - 1) * 0.00001 -\n        +(index === 0) * 0.00001,\n      value\n    }\n  })\n}\n"],"sourceRoot":""}]}